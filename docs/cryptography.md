# Vibecoin Cryptography Documentation

## Overview

This document provides a comprehensive overview of the cryptographic primitives and protocols used in the Vibecoin blockchain. It explains the design choices, security considerations, and implementation details of the cryptographic components.

## Cryptographic Primitives

### Digital Signatures: Ed25519

Vibecoin uses the Ed25519 signature scheme for digital signatures. Ed25519 is a modern, secure, and efficient signature scheme based on elliptic curve cryptography.

**Key Properties:**
- **Security**: Provides 128 bits of security against quantum attacks
- **Performance**: Fast signature generation and verification
- **Size**: Small public keys (32 bytes) and signatures (64 bytes)
- **Deterministic**: Signatures are deterministic, eliminating the need for a secure random number generator during signing
- **Side-channel resistance**: Resistant to many side-channel attacks

**Implementation Details:**
- Uses the `ed25519-dalek` Rust library
- Key generation uses the system's secure random number generator (`OsRng`)
- Signatures are serialized as 64-byte arrays

### Hashing: SHA-256

Vibecoin uses the SHA-256 hash function for various cryptographic operations, including:
- Transaction ID generation
- Block hash calculation
- Merkle tree construction
- Address derivation
- Proof of History sequence

**Key Properties:**
- **Security**: Provides 128 bits of security against collision attacks
- **Performance**: Reasonably fast on modern hardware
- **Standardization**: Widely used and well-analyzed

**Implementation Details:**
- Uses the `sha2` Rust library
- Double-hashing (SHA-256 of SHA-256) is used for additional security in certain contexts
- Hash values are represented as 32-byte arrays

### Merkle Patricia Trie

Vibecoin uses a Merkle Patricia Trie (MPT) for efficient and secure state storage and verification.

**Key Properties:**
- **Efficiency**: Allows for efficient lookups, insertions, and deletions
- **Verifiability**: Enables cryptographic verification of state with compact proofs
- **Sparseness**: Efficiently handles sparse key spaces

**Implementation Details:**
- Custom implementation optimized for Vibecoin's needs
- Supports proof generation and verification
- Uses SHA-256 for node hashing
- Implements node caching for performance

## Cryptographic Protocols

### Transaction Signing and Verification

Transactions in Vibecoin are signed using the following protocol:

1. **Serialization**: The transaction fields (excluding the signature) are serialized in a canonical format
2. **Hashing**: The serialized transaction is hashed using SHA-256 to create the transaction ID
3. **Signing**: The serialized transaction is signed using the sender's private key
4. **Verification**: The signature is verified using the sender's public key

**Security Considerations:**
- The serialization format is deterministic to prevent transaction malleability
- The transaction ID is computed before signing to prevent signature malleability
- Nonces are used to prevent replay attacks

### Address Derivation

Addresses in Vibecoin are derived from public keys using the following process:

1. Generate an Ed25519 keypair
2. Take the 32-byte public key
3. Apply SHA-256 to the public key to get the 32-byte address

**Security Considerations:**
- The use of a cryptographic hash function makes it computationally infeasible to derive the public key from the address
- The 32-byte address space is large enough to prevent collisions

### State Verification

Vibecoin uses Merkle Patricia Tries for state verification:

1. **State Root Calculation**: The state root is calculated as the root hash of the Merkle Patricia Trie containing all account states
2. **Proof Generation**: Proofs are generated by collecting the nodes along the path from the root to the target leaf
3. **Proof Verification**: Proofs are verified by checking that the nodes form a valid path from the root to the leaf

**Security Considerations:**
- Proofs are optimized to minimize size while maintaining security
- The verification process is designed to be efficient for light clients

## Integration with Storage

The cryptographic components are tightly integrated with the storage layer:

1. **Block Storage**: Blocks are indexed by both height and hash
2. **Transaction Storage**: Transactions are indexed by hash and included in blocks
3. **State Storage**: Account states are stored in a Merkle Patricia Trie
4. **Proof of History Storage**: PoH entries are stored with their sequence numbers and hashes

## Security Considerations

### Key Management

- Private keys should never be stored in plaintext
- Key generation should always use a secure random number generator
- Consider implementing key derivation from a seed phrase for backup and recovery

### Side-Channel Attacks

- The Ed25519 implementation is resistant to timing attacks
- Additional precautions should be taken in production environments:
  - Avoid logging sensitive information
  - Implement constant-time comparison for sensitive data
  - Consider using memory zeroization for sensitive data

### Future-Proofing

- The cryptographic primitives chosen are currently considered secure
- A migration path should be planned for potential future upgrades:
  - Post-quantum signature schemes
  - Stronger hash functions if needed
  - More efficient proof systems

## Testing and Validation

The cryptographic components are extensively tested:

- Unit tests for individual components
- Integration tests for component interactions
- Property-based tests for edge cases
- Compliance with cryptographic standards

## References

1. Ed25519: [RFC 8032](https://tools.ietf.org/html/rfc8032)
2. SHA-256: [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf)
3. Merkle Patricia Trie: [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
